<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on Canopy Tech</title>
    <link>https://canopytax.github.io/post/index.xml</link>
    <description>Recent content in Post-rsses on Canopy Tech</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2016</copyright>
    <lastBuildDate>Fri, 16 Sep 2016 08:05:03 -0700</lastBuildDate>
    <atom:link href="https://canopytax.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A case against Angular Upgrade Adapter</title>
      <link>https://canopytax.github.io/post/case-against-angular-upgrade-adapter/</link>
      <pubDate>Fri, 16 Sep 2016 08:05:03 -0700</pubDate>
      
      <guid>https://canopytax.github.io/post/case-against-angular-upgrade-adapter/</guid>
      <description>

&lt;p&gt;If you’re hoping to migrate your Angular 1 application to Angular 2, you’re
going to hear about the &lt;a href=&#34;https://angular.io/docs/ts/latest/guide/upgrade.html&#34;&gt;Angular Upgrade
Adapter&lt;/a&gt;, which let’s you
run ng1 and ng2 apps side by side.&lt;/p&gt;

&lt;p&gt;It’s not that Angular Upgrade Adapter is bad or poorly written or doesn’t work.
And it’s not the Typescript or the Angular 2 or the SystemJS.&lt;/p&gt;

&lt;p&gt;But here are two reasons that will make you think twice about using Angular
Upgrade Adapter:&lt;/p&gt;

&lt;h3 id=&#34;1-you-ll-still-have-to-rewrite-everything&#34;&gt;1. You’ll still have to rewrite everything&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://cdn-images-1.medium.com/max/800/1*VhuRgvrW6GijrjEpZtqnxA.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This comic strip is a real story, and I am the Dilbert. One time at Amazon I
made a joke to my product manager. It was about rewriting code. He didn’t laugh.
Then I joked about how he didn’t think it was funny. Still nothing. Then I
walked away.&lt;/p&gt;

&lt;h3 id=&#34;2-you-ll-probably-have-to-do-this-again-anyways&#34;&gt;2. You’ll probably have to do this again, anyways&lt;/h3&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;I think I&amp;#39;ve had milk last longer than some JavaScript frameworks.&lt;/p&gt;&amp;mdash; I Am Devloper (@iamdevloper) &lt;a href=&#34;https://twitter.com/iamdevloper/status/540481335362875392&#34;&gt;December 4, 2014&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;Developers are just machines that consume Twitter and produce frameworks. And,
really, I wouldn’t have it any other way. Trying out a new framework is just too
fun to give up. And when &lt;em&gt;I’m&lt;/em&gt; not the one pushing for us to try out the new
shiny, somebody else is. Even if we have that big meeting where we talk for an
hour and a half and everyone agrees that Angular 2 is the “framework we decided
on”, it won’t last.&lt;/p&gt;

&lt;h3 id=&#34;so-is-this-just-how-new-frameworks-are&#34;&gt;So is this just how new frameworks are?&lt;/h3&gt;

&lt;p&gt;For a long time I thought the solution to the “framework problem” was staying on
top of everything. If I migrate early to beta versions and release candidates,
somehow that makes my inability to switch frameworks okay. Another thing I
thought was that if I could just find the &lt;em&gt;right framework&lt;/em&gt; that we’d be happy.
Or that somehow we could cure ourselves of the desire to switch frameworks.&lt;/p&gt;

&lt;p&gt;Turns out that’s just not true. And once I accepted that, I realized it’s
totally okay!&lt;/p&gt;

&lt;h3 id=&#34;let-s-get-meta&#34;&gt;Let’s get meta.&lt;/h3&gt;

&lt;p&gt;I think it’s time for the Javascript community to get meta with frameworks.
Instead of finding the &lt;em&gt;right&lt;/em&gt; framework and hoping that it works out, what if
we were capable of simultaneously using any number of frameworks?&lt;/p&gt;

&lt;p&gt;What if we had a bring-your-own-framework mentality where multiple apps
cooperate within one SPA? A framework for using frameworks.&lt;/p&gt;

&lt;p&gt;A Javascript metaframework.&lt;/p&gt;

&lt;p&gt;Where I work this is what we’ve been trying to figure out. What would something
like this even mean? Could we start each project as a green field instead of
locked-in to our previous technology decisions? How do we pull it off?&lt;/p&gt;

&lt;h3 id=&#34;a-different-approach&#34;&gt;A different approach&lt;/h3&gt;

&lt;p&gt;What we’ve come up with is a project called
&lt;a href=&#34;https://github.com/CanopyTax/single-spa&#34;&gt;single-spa&lt;/a&gt; and so far we love it.
It’s an alternative to upgrade guides and migration tools. An early entry to the
nascent world of “Javascript metaframeworks.”&lt;/p&gt;

&lt;p&gt;Instead of migrating your large Angular 1 application to Angular 2, single-spa
has you split it up into several small applications that coexist in the same
SPA. Once split up, you can tackle each one of the applications individually.
When Angular 2 makes sense, migrate one of the apps to be Angular 2. If React
makes sense, rewrite one of them in React.&lt;/p&gt;

&lt;p&gt;Or if you don’t want to rewrite anything at all, just let your application
remain while still giving yourself the option to try something else for new
projects.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://cdn-images-1.medium.com/max/800/1*jiiG-Dxyk6OmVCy2EOtLCA.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;The benefit is that your approach is framework-agnostic. When you want to try
out a new framework, you have a way to do so. Compare this to Angular Upgrade
Adapter, which is a one-way door that leads to Angular 2. What do you do when
you want to try out React or something else?&lt;/p&gt;

&lt;p&gt;What single-spa is doing is managing your applications for you. You can think of
it like a framework agnostic router on top of all other applications. It manages
which applications are active and which ones are dormant.&lt;/p&gt;

&lt;h3 id=&#34;how-to-try-it-out&#34;&gt;How to try it out&lt;/h3&gt;

&lt;p&gt;Single-spa works with es5, es6+, typescript, webpack, systemjs, gulp, grunt,
bower, or really any build system you can think of. You can npm install it, jspm
install it, or even just use a script tag if you prefer. It works in Chrome,
Firefox, Safari, Edge, and (at least) IE11.&lt;/p&gt;

&lt;p&gt;To give it a shot, you’ll have to &lt;a href=&#34;https://github.com/CanopyTax/single-spa/blob/master/docs/migrating-existing-spas.md&#34;&gt;migrate your
SPA&lt;/a&gt;
to become a single-spa child application. After you do so, the entry file to
your application will look something like this:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://cdn-images-1.medium.com/max/800/1*YNZMoyijJown_nOBrQ0wxA.png&#34; alt=&#34; &#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
         
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Once you’ve added a file like this to your app, you’re ready! You can keep your
existing ui-router configuration and your ng1 controllers, services, and
directives.&lt;/p&gt;

&lt;p&gt;The docs for single-spa are &lt;a href=&#34;https://github.com/CanopyTax/single-spa/tree/master/docs&#34;&gt;located
here&lt;/a&gt;, let us know
what you think!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Originally posted at
&lt;a href=&#34;https://medium.com/@joeldenning/a-case-against-angular-update-adapter-d4e121282a11&#34;&gt;https://medium.com/@joeldenning/a-case-against-angular-update-adapter-d4e121282a11&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Case for SOA in the Browser</title>
      <link>https://canopytax.github.io/post/soa-in-the-browser/</link>
      <pubDate>Fri, 26 Feb 2016 08:05:03 -0700</pubDate>
      
      <guid>https://canopytax.github.io/post/soa-in-the-browser/</guid>
      <description>

&lt;p&gt;So you are a web-developer. You write a lot of JavaScript. You have a large
single-page application (SPA) with features to add and bugs to maintain. Over
time the application grows in size and complexity. It becomes more difficult to
modify one portion of the SPA without breaking another portion.&lt;/p&gt;

&lt;p&gt;The company is growing and you are looking for ways to scale the team and
code-base. You add unit tests. You add a linter. You add continuous integration.
You modularize the code with ES2015 modules, webpack, and npm. Eventually you
even introduce new, independent SPAs with each SPA being owned and deployed by
independent squads. Congratulations, you have successfully introduced
service-oriented architecture on the front-end, or have you?&lt;/p&gt;

&lt;h4 id=&#34;what-is-service-oriented-architecture&#34;&gt;What is Service-oriented Architecture?&lt;/h4&gt;

&lt;p&gt;The fundamental concept behind service-oriented architecture is a service. A
service is an isolated piece of code which can only be interacted with through
its API. Unlike a shared library, a service itself can be deployed independently
of its consumers. Think of a back-end API. The API is the service and the
browser is the consumer. The API is deployed independently of the front-end
application. There is also only one deployed version of the API available at a
URL.&lt;/p&gt;

&lt;p&gt;Contrast a service to a shared library. A shared library is a piece of code that
is bundled and deployed with your code. For example, libraries such as Express,
Lodash, and React are all shared libraries included in your application’s
distributable. Upgrading a version of a shared library requires a new deployment
of that distributable.&lt;/p&gt;

&lt;p&gt;Service-oriented architecture is an approach to building software where the
application is composed of many independent and isolated services. Those
services are independently deployable, generally non-versioned, and auto
discoverable.&lt;/p&gt;

&lt;h4 id=&#34;why-service-oriented-architecture-on-the-front-end&#34;&gt;Why Service-oriented Architecture on the Front-end?&lt;/h4&gt;

&lt;p&gt;The benefits of SOA can be illustrated with this real life example from Canopy.
At Canopy we have multiple single page applications. The first application is
external to the customers and the second is internal, yet both applications
share common functionality. That functionality includes among other things,
authentication and error logging.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://cdn-images-1.medium.com/max/800/1*itLASVdD-5a3fm56hfltYQ.png&#34; alt=&#34;Shared libraries between two separate applications. App 1 depends upon shared libs a, b, and c. App 2 depends upon only shared libs a and b.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Shared libraries between two separate applications. App 1 depends upon shared libs a, b, and c. App 2 depends upon only shared libs a and b.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Overall the design looks good. The code is modularized and shared. The
complexities arrive when we start to upgrade the code to different versions. For
example, after a short period of time, &lt;strong&gt;App 2&lt;/strong&gt; (being internal only) is upgraded to a new beta version of the shared lib &lt;strong&gt;b&lt;/strong&gt;. Because the shared
&lt;strong&gt;a&lt;/strong&gt; also depends upon &lt;strong&gt;b&lt;/strong&gt; (and we don’t want multiple versions of b bundled)
we also create a new version of &lt;strong&gt;a&lt;/strong&gt;. This one change causes a rebuild and
deploy of three separate pieces of code: &lt;strong&gt;App 2&lt;/strong&gt; and shared libs &lt;strong&gt;a&lt;/strong&gt; and
&lt;strong&gt;b&lt;/strong&gt;. Our dependency structure is no longer quite so simple.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://cdn-images-1.medium.com/max/1200/1*T5YHqkoZApSvC32jVS0osw.png&#34; alt=&#34;In reality, a duplicate instance of lib a and b exist in both apps. Each app does not point to the same instance of the shared libraries, even when they are the same version. This is more noticeable when the shared libraries have separate versions.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        In reality, a duplicate instance of lib a and b exist in both apps. Each app does not point to the same instance of the shared libraries, even when they are the same version. This is more noticeable when the shared libraries have separate versions.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Now imagine a bug in both versions of shared lib &lt;strong&gt;b&lt;/strong&gt;. In order to fix the
problem, you will have to republish both versions of &lt;strong&gt;a&lt;/strong&gt; and &lt;strong&gt;b&lt;/strong&gt; as well as
&lt;strong&gt;c&lt;/strong&gt;. Also &lt;strong&gt;App 1&lt;/strong&gt; and &lt;strong&gt;App 2&lt;/strong&gt; will have to be re-deployed. That is five
new versions to publish and two apps to redeploy, all to fix one bug. All
downstream dependencies have to be redeployed when a single library is changed.
This is deploy dependency hell.&lt;/p&gt;

&lt;p&gt;Service oriented architecture avoids these problems in a couple ways. Instead of
bundling common dependencies, common code is shared through independent
services. Services are not bundled, but rather loaded at run time. This also
means that front-end services are not versioned (just like a back-end API). Both
&lt;strong&gt;App 1&lt;/strong&gt; and &lt;strong&gt;App 2&lt;/strong&gt; load the exact same code for a front-end service.&lt;/p&gt;

&lt;h4 id=&#34;introducing-sofe&#34;&gt;Introducing sofe&lt;/h4&gt;

&lt;p&gt;Built upon the new ECMAScript module specification, sofe is a JavaScript library
that enables independently deployable JavaScript services to be retrieved at
run-time in the browser. Because the new module specification isn’t available
within today’s browsers, sofe relies upon
&lt;a href=&#34;https://github.com/systemjs/systemjs&#34;&gt;System.js&lt;/a&gt; to load services at run-time.&lt;/p&gt;

&lt;p&gt;You can load a sofe service either with static or asynchronous imports:&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;http://gist.github.com/fb784992748f7d285f35bd26baa8a308.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;The real power behind sofe is that services are resolved at run-time, making
them unversioned. If &lt;strong&gt;auth-service&lt;/strong&gt; is redeployed, it is immediately made
available to all upstream dependencies. The above scenario becomes much easier
to resolve because there is only &lt;em&gt;one&lt;/em&gt; version of each shared library as
services. This is powerful because it allows you to deploy once, update
everywhere. Also because the code is loaded at run-time, we can also enable
developer tools to override what service is loaded into your application. Or in
other words, you can test code on production without actually deploying to
production.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://cdn-images-1.medium.com/max/1000/1*o7IS8yKgYKSDc2w7VpyZFw.png&#34; alt=&#34;The common dependencies are now services that are independent from the application code. Because services are unversioned, the dependency structure is again flat. Each service can individually be deployed and be available to every upstream dependency.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        The common dependencies are now services that are independent from the application code. Because services are unversioned, the dependency structure is again flat. Each service can individually be deployed and be available to every upstream dependency.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;The common dependencies are now services that are independent from the application code. Because services are unversioned, the dependency structure is again flat. Each service can individually be deployed and
be available to every upstream dependency.&lt;/p&gt;

&lt;p&gt;Obviously not all front-end code should be a service. Services have their own
challenges. Specifically your code has to stay backwards compatible. But code
can’t always be backwards compatible. Sometimes there needs to be breaking
changes. The same problem exists for back-end services. A back-end API has to
stay backwards compatible. Breaking changes on the back-end are generally solved
by either creating an entirely new (versioned) API or implementing feature
toggles within the API itself. The same solution applies to sofe services. An
entirely new sofe service can be deployed or feature toggles can exist inside
the front-end service. However it is solved, the key point is that services
exist outside your application within their own distributable.&lt;/p&gt;

&lt;p&gt;Another potential problem for sofe services is performance. Because they are
loaded at run-time, performance can become a concern if you synchronously load
too many services during bootstrap. Performance degradation can be mitigated by
asynchronously loading larger services after the application bootstraps. Despite
these challenges, there are many benefits to services on the front-end. The most
exciting thing about sofe is there is now an option for services in the browser.
You can decide what should and shouldn’t be a service.&lt;/p&gt;

&lt;p&gt;Getting started with sofe requires only System.js. But to help you get started
we have built sofe to work with a variety of technologies, including webpack,
Babel, jspm, and the Chrome Developer Tools. Sofe is also actively used in
production at Canopy Tax. We would love feedback on sofe and a number of open
source projects that have been built around it. As you approach your next
front-end project or look to improve your existing app, consider how it might
benefit from service oriented architecture.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Read more about how to get started with sofe at: &lt;a href=&#34;https://github.com/CanopyTax/sofe&#34;&gt;https://github.com/CanopyTax/sofe&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Originally posted at &lt;a href=&#34;https://medium.com/@blittle/a-case-for-soa-in-the-browser-f777a9f139b2&#34;&gt;https://medium.com/@blittle/a-case-for-soa-in-the-browser-f777a9f139b2&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>